---
category:
  - Knowledge
tags: 
status: Done
---
**核心议题**：不同平台（iOS, Android, Web 浏览器）如何执行应用程序代码、处理硬件多样性以及响应用户输入事件。

### I. iOS 执行模型：原生编译与生态控制

1. **开发语言**：Swift, Objective-C。
2. **编译方式**：
    - 代码由开发者在开发阶段通过编译器（如 LLVM）**直接编译**成目标设备（iPhone/iPad）的 **ARM 架构原生机器码**。
    - 不存在通用的中间字节码层（针对主要应用逻辑）。
3. **执行方式**：
    - 操作系统加载编译好的原生机器码。
    - CPU 直接执行这些机器码指令。
4. **处理硬件多样性的策略**：
    - **严格的硬件控制**：Apple 控制 CPU、GPU 及其他关键硬件规格，减少了开发者需要适配的硬件组合。
    - **统一的 SDK/框架**：提供 Cocoa Touch 等高级 API，封装了硬件访问细节，开发者面向这些稳定的抽象层编程。
    - **App Store 机制 (App Thinning)**：根据用户设备特性，仅分发所需的最小化原生代码版本。
5. **维护性**：尽管是原生编译，但通过上述控制和抽象策略，Apple 确保了在自家硬件生态内的可维护性。
6. **事件处理**：
    - 内核检测到硬件事件（键盘、触摸）。
    - 内核向 **iOS App 进程**发送事件消息。
    - App 内的事件循环（原生代码）接收消息。
    - 事件循环调用 App 内对应的**预编译好的原生事件处理函数**。

### II. Android 执行模型：运行时抽象与 AOT/JIT

1. **开发语言**：Kotlin, Java (主流)；也支持 C/C++ (通过 NDK)。
2. **编译方式 (主流)**：
    - 源代码 (Kotlin/Java) 编译成 JVM 字节码，再转换为 **DEX (Dalvik Executable) 字节码**。
3. **执行方式 (ART - Android Runtime)**：
    - **AOT (Ahead-of-Time) 编译**：应用**安装时**，ART 将 DEX 字节码编译成设备**原生机器码**。应用运行时主要执行的是这些预编译的本地代码。
    - **JIT (Just-In-Time) 编译**：ART 仍具备 JIT 能力，用于运行时的进一步优化。
    - **抽象层**：ART 运行时环境 + Android SDK/API 共同构成了强大的抽象，屏蔽了底层硬件差异。
    - _(历史：早期使用 Dalvik VM，以解释执行和 JIT 为主)_
4. **处理硬件多样性的策略**：
    - **核心依赖运行时/API 抽象**：ART 和标准 Android API 是适配种类繁多的硬件（不同厂商、CPU、屏幕等）的关键。开发者面向通用字节码和 API 编程。
5. **维护性**：通过运行时和 API 提供的抽象层，实现了在高度碎片化硬件生态中的应用可维护性。
6. **事件处理 (标准应用)**：
    - 内核检测到硬件事件。
    - 内核通知 **Android 系统框架/服务**。
    - 系统框架将事件传递给 **App 进程 (运行在 ART 环境中)**。
    - App 内的事件处理代码（最终以本地机器码形式在 ART 中执行）被调用。

### III. Web 浏览器执行模型：平台虚拟机与高度抽象

1. **角色定位**：可视为一个面向 Web 技术的**特定执行平台**或**高级虚拟机**。
2. **执行内容**：
    - **JavaScript**：通过内置的 JS 引擎（如 V8，本身就是 JS 虚拟机，使用 JIT/解释）。
    - **WebAssembly (Wasm)**：通过内置的 Wasm 运行时/虚拟机执行。
    - **HTML/CSS**：通过渲染引擎解释并布局显示。
3. **执行方式**：
    - JS/Wasm 代码在各自的虚拟机/运行时中执行。
    - 提供了极高层次的抽象 API (DOM, BOM, Fetch API, Canvas API 等)，完全屏蔽 OS 和硬件细节。
4. **处理硬件/平台多样性的策略**：
    - **依赖浏览器自身**：浏览器作为跨平台应用程序，其本身负责适配底层操作系统和硬件。
    - **标准化的 Web API**：开发者面向这些统一的 API 编程，确保 Web 应用在不同浏览器和操作系统上表现（理论上）一致。
5. **维护性**：Web 应用的跨平台维护性极高，得益于浏览器提供的强大抽象和标准化环境。
6. **事件处理 (JavaScript)**：
    - 内核检测到硬件事件。
    - 内核通知**浏览器进程**（它是一个原生应用）。
    - 浏览器的事件循环（原生代码）接收事件。
    - 浏览器判断事件目标，若有 JS 监听器，则**调用 JS 虚拟机 (V8)**。
    - JS 虚拟机执行对应的 **JavaScript 事件处理函数**。

### IV. 总结与关键区别

- **目标**：三者都旨在让应用能在目标设备上运行，但实现路径和侧重不同。
- **核心策略**：
    - iOS：**原生编译 + 生态控制**，追求性能和一致性。
    - Android：**运行时抽象 (ART) + API 标准化**，适应开放和多样化的硬件。
    - 浏览器：**平台级虚拟机 + 高度抽象 API**，实现极致的跨平台 Web 应用。
- **对硬件的态度**：
    - iOS：严格控制。
    - Android：通过运行时拥抱多样性。
    - 浏览器：完全屏蔽。
- **事件流**：内核总是起点，但事件消息如何到达并触发最终的应用代码，路径因平台架构而异（原生直达 vs. 运行时/框架中转 vs. 浏览器中转给 JS VM）。

