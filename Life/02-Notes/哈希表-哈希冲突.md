---
category:
- Tech
tags:
- Data-Structure
status: Done
---



哈希冲突（Hash Collision）是指两个不同的键（key）被映射到相同的哈希值时，如何处理这个问题是哈希表设计中的一个关键。你提到的两种常见的冲突解决方案：**链地址法** 和 **开放寻址法**，它们是应对哈希冲突的不同策略，具体解释如下：

#### 1.  链地址法（Chaining）

链地址法的基本思想是：**每个桶存储一个链表**。当不同的键被哈希到相同的哈希值（即相同的桶）时，这些冲突的元素被组织成一个链表。简单来说，每个桶不再只存储一个元素，而是可以存储多个元素的链表。

**如何处理冲突？**

- 当发生哈希冲突时，不是简单地用新元素替换掉已有的元素，而是将新元素**插入到该桶的链表中**，与已经存在的元素一起存储。
- 这样即使哈希表有冲突，多个元素共享相同的桶，并且通过链表串联在一起，不会丢失数据。

**优点**：

- 内存使用较为灵活：只有当发生冲突时，才会分配额外的内存来存储链表中的元素。
- 哈希表的容量不会因为冲突而显著增大：因为冲突的元素被存储在链表中，哈希表的数组大小不受影响。

**缺点**：

- 如果某些桶的链表过长，查询的效率会下降，因为你需要遍历链表来找到目标元素。最糟糕的情况下，如果所有元素都被哈希到同一个桶，链表的长度接近所有元素的数量，这时哈希表的查询性能接近链表的线性搜索（O(n)）。

#### 2. 开放寻址法（Open Addressing）

开放寻址法的核心思想是：**所有元素都存储在哈希表的数组中**，不会有额外的链表或其他结构。**当发生冲突时，继续寻找数组中的下一个空位置**来插入元素。

**常见的开放寻址方法**：

- **线性探测（Linear Probing）**：当发生冲突时，继续检查数组的**下一个位置**，依次向后寻找，直到找到一个空位置。如果到达数组末尾，可以回到数组的开头继续寻找。

- **二次探测（Quadratic Probing）**：与线性探测不同，二次探测在发生冲突时，会按一定的**二次方间隔**（如 1, 4, 9, 16…）来寻找空位置。这种方式比线性探测能更好地避免“群集”（clustering）现象。

**优点**：

- 整个哈希表的数据都存储在数组中，内存布局紧凑，没有额外的链表或指针结构，所以能有效利用 CPU 缓存，提升访问速度。

**缺点**：
- 如果哈希表的**装填因子（load factor）** 接近 1（即哈希表快满了），找到空位置的代价会变得很高，影响查找效率。通常建议哈希表在装填因子达到一定比例（如 0.75）时进行扩容，以避免性能下降。

#### 3. 总结

- **链地址法**使用链表来处理冲突，内存使用灵活，但在冲突严重时，链表查找效率低。

- **开放寻址法**通过在数组中继续寻找空位置来解决冲突，没有额外的结构，但当哈希表过满时，查找空位置的效率可能会下降。

这两种方法各有优劣，具体的选择取决于应用场景、内存需求和哈希冲突的分布情况。在实际应用中，链地址法常用于大多数哈希表实现中，因为它的扩展性更好，而开放寻址法更适合对内存紧凑度要求较高的场景。