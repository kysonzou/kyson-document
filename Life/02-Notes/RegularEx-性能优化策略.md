---
category:
  - Tech
tags:
  - RegularE
status: Done
---
- 巧用懒惰模式
- 尽量限制匹配范围
- 捕获分组替换为非捕获分组
- 简化表达式（使用字符类代替分支）
- 某些时候可以分步匹配
- 避免零宽断言的过渡使用（也可能会造成过渡回溯的问题，每次从头计算模式）
#### **1 避免过度使用贪婪匹配**

默认情况下，量词如 \*、+ 等是贪婪的，会尽可能多地匹配内容。当不需要匹配尽量多的字符时，应考虑使用懒惰量词 \*?、\+?，或限定匹配范围。

**示例**：优化匹配 \<b>content\</b>。

- 贪婪匹配（低效）：\<b>.*\</b>

- 懒惰匹配（更高效）：\<b>.*?\</b>

#### **2 减少回溯：尽量限制量词范围**

不限定匹配次数的量词（如 \.\*）在复杂表达式中会产生大量回溯。可以使用限定量词 {n,m} 来减少回溯。例如：

**示例**：匹配 5 到 10 个数字。

- 使用不定量词（低效）：\d+

- 使用限定量词（更高效）：\d{5,10}

#### **3 优化字符类和分组**

字符类 \[a-zA-Z0-9] 和捕获分组 ( ... ) 是正则表达式中的常用结构。若不需要引用分组内容，尽量使用**非捕获分组** (?: ... )，减少内存和时间消耗。

**示例**：匹配多个单词，不捕获分组。

- 捕获分组（低效）：(word1|word2|word3)

- 非捕获分组（更高效）：(?:word1|word2|word3)

#### **4 简化表达式**

一些复杂的表达式可以通过重新设计简化。例如，使用字符类代替多个分支匹配，或用更简单的量词替代复杂的模式。

**示例**：匹配数字或字母。

- 分支匹配（低效）：(a|b|c|d|1|2|3|4)

- 字符类（更高效）：\[a-d1-4]

#### **5 预先验证字符串结构**

在某些情况下，可以通过正则表达式前先进行简单的字符检查来提升性能。比如，处理特定开头或长度的字符串时，先检查这些条件再使用正则匹配可以减少不必要的计算。

**示例**：只匹配以 “abc” 开头的 10 个字符。
```python
# 简单检查
if len(text) >= 10 and text.startswith("abc"):
    # 进一步匹配
    re.match(r"abc\d+", text)
```
  
#### **6 避免零宽断言的过度使用**

零宽断言（(?=...) 和 (?!...)）是有条件匹配，虽然强大但也可能导致过度回溯，尤其在长字符串中。仅在必要时使用断言，以减少额外计算。

  

