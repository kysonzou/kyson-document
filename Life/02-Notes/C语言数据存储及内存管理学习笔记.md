---
category:
- Tech
tags: null
status: Done
---



> 最近在[home.edx.org](https://home.edx.org)看计算机科学知识的笔记

#### **1. 基本数据类型的存储方式**

• **int**: 整数类型，通常占用4个字节（32位），根据系统的不同可能有差异，存储整数值。

• **long**: 较大的整数类型，通常占用8个字节（64位），可以存储更大的整数。

• **float**: 单精度浮点数，占用4个字节（32位），用于存储带小数的数值，精度较低。

• **double**: 双精度浮点数，占用8个字节（64位），用于存储带小数的数值，精度较高。

• **char**: 字符类型，占用1个字节（8位），用于存储单个字符或ASCII值。

• **string**: 字符串是字符数组的特殊形式，最后一个字符是空字符\0，用于标识字符串的结束。

• **array**: 数组是一组相同类型元素的集合，连续存储在内存中，元素类型和数组长度决定数组的大小。

#### **2. 指针与内存管理**

• **指针**: 指针是一种特殊的变量，用来存储内存地址。C语言的指针通常占用8个字节（64位系统），可通过取地址符号&获取变量的内存地址，使用*符号访问指针指向的内容。

示例：
```c
int a = 10;

int *p = &a; // p存储a的地址

int b = *p;  // b获得p指向的a的值，即10
```
  
#### **3. 栈、堆、字符串字面量**

• **栈（Stack）**: 栈是内存的一部分，存储函数调用时的局部变量和返回地址。栈内存自动管理，变量超出作用域时会自动释放。

• **堆（Heap）**: 堆是另一部分内存，动态分配使用。程序可以通过malloc等函数在运行时申请内存，但需要手动释放（如通过free）。

• **字符串字面量**: C语言中的字符串字面量存储在只读内存区，它们是以空字符\0结尾的字符数组。

#### **4. NULL与内存地址**

• **NULL**: 在C语言中，NULL通常表示一个空指针，即指向内存地址0。使用NULL可以标识一个未初始化或无效的指针。

#### **5. 总结**

C语言的内存管理是关键知识，包括数据类型的存储、指针的操作、栈和堆的使用、以及字符串的特殊处理。理解这些概念有助于编写更高效、安全的C程序。


#### 6. 问题

>[!question] char* word = "中文"; // 使用标准C语言的字符串 那这么写是c语言自动给我们分类字符大小吗?

在C语言中，像 char* word = "中文"; 这样的写法并不会自动为你处理字符的大小分类。C语言中的 char 类型代表单个字节（1字节 = 8位），而中文字符通常在 UTF-8 编码中需要2到3个字节来表示。因此，C语言只是简单地将字符串 "中文" 按照字节顺序存储，而不会“自动分类”或识别字符的大小。

**具体解释**

1. **C语言中的字符类型**：

   -  char 在 C 语言中表示一个字节的字符（8位），适合处理 ASCII 字符集（即0-127范围的字符），因为每个 ASCII 字符只占用1个字节。

   -  但是，当涉及非 ASCII 字符（如中文）时，这些字符在常见的编码方案（如 UTF-8）中通常会占用多个字节。

2. **UTF-8 编码下的中文字符**：

   -  UTF-8 是一种变长的字符编码方案，它可以用1到4个字节来表示不同的字符。

   -  中文字符在 UTF-8 中通常占用3个字节。例如，"中文" 这个字符串的第一个字符 中 在 UTF-8 中由三个字节 0xE4 0xB8 0xAD 组成，第二个字符 文 由三个字节 0xE6 0x96 0x87 组成。

3. **C语言中的字符串存储**：

   -  当你写 char* word = "中文"; 时，C语言会将这个 UTF-8 编码的字符串逐字节存储在内存中。因此，word[0] 对应的只是 UTF-8 编码的第一个字节，而不是完整的第一个字符。

   -  举例说明，"中文" 在内存中的存储结构如下：

      ```text
      word[0] = 0xE4  // '中' 的第一个字节
      
      word[1] = 0xB8  // '中' 的第二个字节
      
      word[2] = 0xAD  // '中' 的第三个字节
      
      word[3] = 0xE6  // '文' 的第一个字节
      
      word[4] = 0x96  // '文' 的第二个字节
      
      word[5] = 0x87  // '文' 的第三个字节
      
      word[6] = 0x00  // 终止符 '\0'
      ```

4. **访问和处理多字节字符**：

   - 如果你直接访问 word[0]，你得到的只是 0xE4，这只是 中 字符的第一个字节，而不是完整的 中 字符。

   - C语言并不会自动帮你解析完整的多字节字符。如果你想正确处理多字节字符（如中文），你需要使用专门的函数库，例如 wchar_t 或 mbstowcs（多字节到宽字符转换）等，或者使用更高级的语言库来处理 Unicode 字符串。

**总结**

C语言中的 char* word = "中文"; 并不会自动区分字符大小。C语言会逐字节存储字符串，UTF-8 编码的多字节字符会被分解成若干字节存储。因此，如果要正确处理中文等多字节字符，你需要手动使用合适的字符处理方法或库，而 C语言本身不会自动帮助你“分类”字符的大小。

>[!question] 意思就是 char* word = "中文"这么写其实是不对的对吗？因为char是字节，而“中文不是一个字节表示的”，所以这么写不对吗?

实际上，char* word = "中文"; 这样的写法在 C 语言中是**可以工作的**，但有一些潜在的问题需要注意：

1. **C语言中的字符串表示**：

   -  在 C 语言中，字符串实际上是由字符数组（或字符指针 char*）表示，并且每个字符都以 char 类型（一个字节，8位）存储。因此，char* word = "中文"; 是合法的写法，因为 "中文" 是一个字符串字面量，并且以 UTF-8 编码存储在程序的内存中。

   - 由于 "中文" 是 UTF-8 编码的，尽管单个 char 是一个字节，但 UTF-8 编码允许一个字符由多个字节表示。因此，char* word = "中文"; 实际上是存储了 "中文" 的 UTF-8 编码的字节序列。

2. **UTF-8 编码中的多字节字符**：

   - 在 UTF-8 编码中，中文字符需要用 3 个字节来表示。例如，字符 中 的 UTF-8 编码是 0xE4 0xB8 0xAD，字符 文 的编码是 0xE6 0x96 0x87。

   - 这意味着 word[0] 并不会是完整的字符 中，而只是 中 字符的第一个字节 0xE4。

3. **结论：写法本身是正确的，但访问和处理时需要小心**：

   - 虽然你可以用 char* word = "中文"; 这样定义 UTF-8 字符串，但问题出在你如何访问和处理它。因为每个中文字符由多个字节组成，而 char 类型只能访问单个字节，因此如果你逐个访问 word[i]，你得到的只是 UTF-8 编码的一个字节，而不是完整的中文字符。

